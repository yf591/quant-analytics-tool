"""
Strategy framework for backtesting engine.

This module provides a base strategy class and several concrete strategy
implementations for quantitative trading. Strategies define the logic for
generating trading signals based on market data and portfolio state.

The framework supports:
- Abstract base strategy class with standard interface
- Event-driven strategy execution
- Signal generation and position sizing
- Risk management integration
- Multiple strategy types (momentum, mean reversion, machine learning)
"""

from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Tuple, Any
import logging
import pandas as pd
import numpy as np
from datetime import datetime
from dataclasses import dataclass
from enum import Enum

from .engine import OrderSide, OrderType

logger = logging.getLogger(__name__)


class SignalType(Enum):
    """Signal types for trading strategies."""

    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    CLOSE_LONG = "close_long"
    CLOSE_SHORT = "close_short"


@dataclass
class Signal:
    """
    Trading signal generated by a strategy.

    Attributes:
        symbol: Trading symbol
        signal_type: Type of signal (buy, sell, hold, etc.)
        strength: Signal strength (0.0 to 1.0)
        confidence: Confidence level (0.0 to 1.0)
        size: Suggested position size (number of shares)
        timestamp: Signal generation time
        metadata: Additional signal metadata
    """

    symbol: str
    signal_type: SignalType
    strength: float = 0.0
    confidence: float = 0.0
    size: int = 0
    timestamp: Optional[datetime] = None
    metadata: Optional[Dict[str, Any]] = None

    def __post_init__(self):
        """Validate signal parameters."""
        if not 0.0 <= self.strength <= 1.0:
            raise ValueError(
                f"Signal strength must be between 0.0 and 1.0, got {self.strength}"
            )
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError(
                f"Signal confidence must be between 0.0 and 1.0, got {self.confidence}"
            )
        if self.timestamp is None:
            self.timestamp = datetime.now()
        if self.metadata is None:
            self.metadata = {}


class BaseStrategy(ABC):
    """
    Abstract base class for trading strategies.

    This class defines the interface that all strategies must implement.
    Strategies are responsible for generating trading signals based on
    market data and portfolio state.
    """

    def __init__(
        self,
        name: str,
        symbols: List[str],
        lookback_period: int = 20,
        min_confidence: float = 0.5,
        max_position_size: float = 0.1,
        risk_free_rate: float = 0.02,
    ):
        """
        Initialize base strategy.

        Args:
            name: Strategy name
            symbols: List of symbols to trade
            lookback_period: Number of periods to look back for analysis
            min_confidence: Minimum confidence required for signal generation
            max_position_size: Maximum position size as fraction of portfolio
            risk_free_rate: Risk-free rate for calculations
        """
        self.name = name
        self.symbols = symbols
        self.lookback_period = lookback_period
        self.min_confidence = min_confidence
        self.max_position_size = max_position_size
        self.risk_free_rate = risk_free_rate

        # Strategy state
        self.is_initialized = False
        self.current_signals: Dict[str, Signal] = {}
        self.signal_history: List[Signal] = []
        self.backtest_engine = None

        logger.info(f"Initialized strategy: {self.name}")

    def set_backtest_engine(self, engine):
        """Set reference to backtest engine."""
        self.backtest_engine = engine

    @abstractmethod
    def on_start(self) -> None:
        """Called when backtesting starts."""
        pass

    @abstractmethod
    def on_data(self, current_time: datetime) -> List[Signal]:
        """
        Called on each data update during backtesting.

        Args:
            current_time: Current simulation time

        Returns:
            List of trading signals
        """
        pass

    @abstractmethod
    def on_finish(self) -> None:
        """Called when backtesting finishes."""
        pass

    def get_market_data(
        self, symbol: str, periods: Optional[int] = None
    ) -> pd.DataFrame:
        """
        Get market data for a symbol.

        Args:
            symbol: Symbol to get data for
            periods: Number of periods to retrieve (default: lookback_period)

        Returns:
            DataFrame with market data
        """
        if self.backtest_engine is None:
            raise RuntimeError("Strategy not connected to backtest engine")

        if periods is None:
            periods = self.lookback_period

        current_time = self.backtest_engine.current_time
        if current_time is None:
            return pd.DataFrame()

        data = self.backtest_engine.market_data.get(symbol, pd.DataFrame())
        if data.empty:
            return pd.DataFrame()

        # Get data up to current time
        mask = data.index <= current_time
        recent_data = data[mask].tail(periods)

        return recent_data

    def get_current_price(self, symbol: str) -> Optional[float]:
        """Get current price for a symbol."""
        if self.backtest_engine is None:
            return None
        return self.backtest_engine.get_current_price(symbol)

    def get_portfolio_value(self) -> float:
        """Get current portfolio value."""
        if self.backtest_engine is None:
            return 0.0
        return self.backtest_engine.get_portfolio_value()

    def get_position(self, symbol: str):
        """Get current position for a symbol."""
        if self.backtest_engine is None:
            return None
        return self.backtest_engine.positions.get(symbol)

    def calculate_position_size(
        self,
        symbol: str,
        signal_strength: float,
        confidence: float,
        volatility: Optional[float] = None,
    ) -> int:
        """
        Calculate position size based on signal and risk parameters.

        Args:
            symbol: Trading symbol
            signal_strength: Signal strength (0.0 to 1.0)
            confidence: Signal confidence (0.0 to 1.0)
            volatility: Price volatility (optional)

        Returns:
            Position size in shares
        """
        portfolio_value = self.get_portfolio_value()
        current_price = self.get_current_price(symbol)

        if portfolio_value <= 0 or current_price is None or current_price <= 0:
            return 0

        # Base position size as percentage of portfolio
        base_size = portfolio_value * self.max_position_size

        # Adjust for signal strength and confidence
        adjusted_size = base_size * signal_strength * confidence

        # Adjust for volatility if provided (higher volatility = smaller position)
        if volatility is not None and volatility > 0:
            vol_adjustment = min(1.0, 0.2 / volatility)  # Target 20% volatility
            adjusted_size *= vol_adjustment

        # Convert to shares
        shares = int(adjusted_size / current_price)

        return max(0, shares)

    def generate_signal(
        self,
        symbol: str,
        signal_type: SignalType,
        strength: float,
        confidence: float,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> Signal:
        """
        Generate a trading signal.

        Args:
            symbol: Trading symbol
            signal_type: Type of signal
            strength: Signal strength
            confidence: Signal confidence
            metadata: Additional metadata

        Returns:
            Generated signal
        """
        if confidence < self.min_confidence:
            signal_type = SignalType.HOLD
            strength = 0.0

        size = 0
        if signal_type in [SignalType.BUY, SignalType.SELL]:
            # Calculate volatility for position sizing
            data = self.get_market_data(symbol, 20)
            volatility = None
            if len(data) >= 2:
                returns = data["Close"].pct_change().dropna()
                volatility = returns.std() * np.sqrt(252)  # Annualized

            size = self.calculate_position_size(
                symbol, strength, confidence, volatility
            )

        signal = Signal(
            symbol=symbol,
            signal_type=signal_type,
            strength=strength,
            confidence=confidence,
            size=size,
            timestamp=(
                self.backtest_engine.current_time
                if self.backtest_engine
                else datetime.now()
            ),
            metadata=metadata or {},
        )

        # Store signal
        self.current_signals[symbol] = signal
        self.signal_history.append(signal)

        return signal

    def execute_signal(self, signal: Signal) -> bool:
        """
        Execute a trading signal by placing orders.

        Args:
            signal: Signal to execute

        Returns:
            True if signal was executed successfully
        """
        if self.backtest_engine is None:
            logger.warning("No backtest engine available for signal execution")
            return False

        try:
            current_position = self.get_position(signal.symbol)
            current_quantity = current_position.quantity if current_position else 0

            if signal.signal_type == SignalType.BUY:
                if signal.size > 0:
                    self.backtest_engine.place_order(
                        signal.symbol, OrderSide.BUY, signal.size, OrderType.MARKET
                    )
                    return True

            elif signal.signal_type == SignalType.SELL:
                if signal.size > 0:
                    self.backtest_engine.place_order(
                        signal.symbol, OrderSide.SELL, signal.size, OrderType.MARKET
                    )
                    return True

            elif signal.signal_type == SignalType.CLOSE_LONG:
                if current_quantity > 0:
                    self.backtest_engine.place_order(
                        signal.symbol,
                        OrderSide.SELL,
                        abs(current_quantity),
                        OrderType.MARKET,
                    )
                    return True

            elif signal.signal_type == SignalType.CLOSE_SHORT:
                if current_quantity < 0:
                    self.backtest_engine.place_order(
                        signal.symbol,
                        OrderSide.BUY,
                        abs(current_quantity),
                        OrderType.MARKET,
                    )
                    return True

        except Exception as e:
            logger.error(f"Error executing signal for {signal.symbol}: {str(e)}")
            return False

        return False


class BuyAndHoldStrategy(BaseStrategy):
    """
    Simple buy and hold strategy.

    Buys a fixed amount on the first day and holds until the end.
    """

    def __init__(self, symbols: List[str], **kwargs):
        super().__init__("BuyAndHold", symbols, **kwargs)
        self.has_bought = set()

    def on_start(self):
        """Initialize strategy."""
        self.is_initialized = True
        self.has_bought.clear()
        logger.info(f"Starting {self.name} strategy for symbols: {self.symbols}")

    def on_data(self, current_time: datetime) -> List[Signal]:
        """Generate buy signals on first data point for each symbol."""
        signals = []

        for symbol in self.symbols:
            if symbol not in self.has_bought:
                # Generate buy signal
                signal = self.generate_signal(
                    symbol=symbol,
                    signal_type=SignalType.BUY,
                    strength=1.0,
                    confidence=1.0,
                    metadata={"strategy": "buy_and_hold", "initial_buy": True},
                )
                signals.append(signal)
                self.has_bought.add(symbol)

                # Execute the signal
                self.execute_signal(signal)

        return signals

    def on_finish(self):
        """Clean up strategy."""
        logger.info(f"Finished {self.name} strategy")


class MomentumStrategy(BaseStrategy):
    """
    Momentum strategy based on price trends.

    Generates buy signals when price is trending up and sell signals
    when trending down, based on moving average crossovers.
    """

    def __init__(
        self,
        symbols: List[str],
        short_window: int = 10,
        long_window: int = 20,
        **kwargs,
    ):
        super().__init__("Momentum", symbols, **kwargs)
        self.short_window = short_window
        self.long_window = long_window
        self.lookback_period = max(long_window + 5, kwargs.get("lookback_period", 30))

    def on_start(self):
        """Initialize strategy."""
        self.is_initialized = True
        logger.info(
            f"Starting {self.name} strategy with windows {self.short_window}/{self.long_window}"
        )

    def on_data(self, current_time: datetime) -> List[Signal]:
        """Generate momentum signals based on moving average crossover."""
        signals = []

        for symbol in self.symbols:
            data = self.get_market_data(symbol, self.lookback_period)

            if len(data) < self.long_window:
                continue

            # Calculate moving averages
            short_ma = data["Close"].rolling(window=self.short_window).mean()
            long_ma = data["Close"].rolling(window=self.long_window).mean()

            if len(short_ma) < 2 or len(long_ma) < 2:
                continue

            # Current and previous values
            current_short = short_ma.iloc[-1]
            current_long = long_ma.iloc[-1]
            prev_short = short_ma.iloc[-2]
            prev_long = long_ma.iloc[-2]

            # Check for crossover
            current_position = self.get_position(symbol)
            position_quantity = current_position.quantity if current_position else 0

            signal_type = SignalType.HOLD
            strength = 0.0
            confidence = 0.5

            # Golden cross (buy signal)
            if prev_short <= prev_long and current_short > current_long:
                if position_quantity <= 0:  # Not long or flat
                    signal_type = SignalType.BUY
                    strength = min(
                        1.0, abs(current_short - current_long) / current_long
                    )
                    confidence = 0.7

            # Death cross (sell signal)
            elif prev_short >= prev_long and current_short < current_long:
                if position_quantity >= 0:  # Not short or flat
                    if position_quantity > 0:
                        signal_type = SignalType.CLOSE_LONG
                    else:
                        signal_type = SignalType.SELL
                    strength = min(
                        1.0, abs(current_short - current_long) / current_long
                    )
                    confidence = 0.7

            if signal_type != SignalType.HOLD:
                signal = self.generate_signal(
                    symbol=symbol,
                    signal_type=signal_type,
                    strength=strength,
                    confidence=confidence,
                    metadata={
                        "short_ma": current_short,
                        "long_ma": current_long,
                        "crossover": True,
                    },
                )
                signals.append(signal)
                self.execute_signal(signal)

        return signals

    def on_finish(self):
        """Clean up strategy."""
        logger.info(f"Finished {self.name} strategy")


class MeanReversionStrategy(BaseStrategy):
    """
    Mean reversion strategy based on Bollinger Bands.

    Generates buy signals when price is below lower band and sell signals
    when price is above upper band.
    """

    def __init__(
        self, symbols: List[str], window: int = 20, num_std: float = 2.0, **kwargs
    ):
        super().__init__("MeanReversion", symbols, **kwargs)
        self.window = window
        self.num_std = num_std
        self.lookback_period = max(window + 5, kwargs.get("lookback_period", 30))

    def on_start(self):
        """Initialize strategy."""
        self.is_initialized = True
        logger.info(
            f"Starting {self.name} strategy with window {self.window}, std {self.num_std}"
        )

    def on_data(self, current_time: datetime) -> List[Signal]:
        """Generate mean reversion signals based on Bollinger Bands."""
        signals = []

        for symbol in self.symbols:
            data = self.get_market_data(symbol, self.lookback_period)

            if len(data) < self.window:
                continue

            # Calculate Bollinger Bands
            close_prices = data["Close"]
            rolling_mean = close_prices.rolling(window=self.window).mean()
            rolling_std = close_prices.rolling(window=self.window).std()

            upper_band = rolling_mean + (rolling_std * self.num_std)
            lower_band = rolling_mean - (rolling_std * self.num_std)

            if len(upper_band) < 1 or len(lower_band) < 1:
                continue

            current_price = close_prices.iloc[-1]
            current_mean = rolling_mean.iloc[-1]
            current_upper = upper_band.iloc[-1]
            current_lower = lower_band.iloc[-1]

            current_position = self.get_position(symbol)
            position_quantity = current_position.quantity if current_position else 0

            signal_type = SignalType.HOLD
            strength = 0.0
            confidence = 0.6

            # Price below lower band (oversold - buy signal)
            if current_price < current_lower:
                if position_quantity <= 0:  # Not long
                    signal_type = SignalType.BUY
                    strength = min(1.0, (current_lower - current_price) / current_lower)
                    confidence = 0.7

            # Price above upper band (overbought - sell signal)
            elif current_price > current_upper:
                if position_quantity >= 0:  # Not short
                    if position_quantity > 0:
                        signal_type = SignalType.CLOSE_LONG
                    else:
                        signal_type = SignalType.SELL
                    strength = min(1.0, (current_price - current_upper) / current_upper)
                    confidence = 0.7

            # Price returned to mean (close position)
            elif position_quantity != 0:
                distance_from_mean = abs(current_price - current_mean) / current_mean
                if distance_from_mean < 0.01:  # Within 1% of mean
                    if position_quantity > 0:
                        signal_type = SignalType.CLOSE_LONG
                    else:
                        signal_type = SignalType.CLOSE_SHORT
                    strength = 0.5
                    confidence = 0.6

            if signal_type != SignalType.HOLD:
                signal = self.generate_signal(
                    symbol=symbol,
                    signal_type=signal_type,
                    strength=strength,
                    confidence=confidence,
                    metadata={
                        "current_price": current_price,
                        "mean": current_mean,
                        "upper_band": current_upper,
                        "lower_band": current_lower,
                        "distance_from_mean": abs(current_price - current_mean)
                        / current_mean,
                    },
                )
                signals.append(signal)
                self.execute_signal(signal)

        return signals

    def on_finish(self):
        """Clean up strategy."""
        logger.info(f"Finished {self.name} strategy")
